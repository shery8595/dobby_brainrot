<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Summarizer</title>
    <!-- Add required libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.21/mammoth.browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 24px;
            color: #1a1a1a;
            line-height: 1.6;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 32px 64px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(255, 255, 255, 0.1);
            overflow: hidden;
            position: relative;
            z-index: 2;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            overflow: hidden;
            display: block;
        }
        
        #minecraftVideo {
            position: absolute;
            top: 50%;
            left: 50%;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            transform: translateX(-50%) translateY(-50%);
            object-fit: cover;
        }
        
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
        }
        
        .subtitles {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #00ff41;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.4em;
            text-align: center;
            max-width: 80%;
            z-index: 10;
            border: 2px solid #00ff41;
            display: none;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            padding: 48px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M30 30c0 16.569-13.431 30-30 30s-30-13.431-30-30 13.431-30 30-30 30 13.431 30 30z'/%3E%3C/g%3E%3C/svg%3E");
        }
        
        .header h1 {
            font-size: 3.2rem;
            font-weight: 700;
            margin-bottom: 16px;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
            background: linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header p {
            font-size: 1.25rem;
            font-weight: 400;
            opacity: 0.9;
            position: relative;
            z-index: 1;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .main-content {
            padding: 48px 40px;
            background: transparent;
            color: #1a1a1a;
        }
        
        .upload-section {
            border: 2px dashed #e2e8f0;
            border-radius: 20px;
            padding: 48px 40px;
            text-align: center;
            margin-bottom: 32px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            background: rgba(102, 126, 234, 0.02);
            position: relative;
            overflow: hidden;
        }
        
        .upload-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .upload-section:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.15);
        }
        
        .upload-section:hover::before {
            opacity: 1;
        }
        
        .upload-section.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.12);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        #fileInput {
            display: none;
        }
        
        .upload-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: none;
            letter-spacing: 0.01em;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .upload-button::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
        }
        
        .upload-button:hover::before {
            left: 100%;
        }
        
        .upload-button:active {
            transform: translateY(0);
        }
        
        .file-info {
            margin: 24px 0;
            padding: 20px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            display: none;
            font-size: 0.95rem;
            color: #4a5568;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 6px;
            margin: 24px 0;
            overflow: hidden;
            display: none;
            border: none;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 6px;
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        
        .results-section {
            display: none;
            margin-top: 30px;
        }
        
        .summary-box {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 16px;
            padding: 32px;
            margin: 24px 0;
            position: relative;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
        }
        
        .summary-title {
            color: #2d3748;
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 700;
            letter-spacing: -0.01em;
        }
        
        .summary-text {
            line-height: 1.7;
            color: #4a5568;
            font-size: 1rem;
            font-weight: 400;
        }
        
        .audio-section {
            text-align: center;
            margin-top: 25px;
        }
        
        .audio-player {
            width: 100%;
            max-width: 400px;
            margin: 15px auto;
            filter: hue-rotate(120deg) saturate(1.5);
        }
        
        .error {
            background: rgba(245, 101, 101, 0.1);
            color: #e53e3e;
            padding: 20px;
            border-radius: 12px;
            margin: 16px 0;
            display: none;
            border: 1px solid rgba(245, 101, 101, 0.3);
            font-size: 0.95rem;
            font-weight: 500;
        }
        
        .loading {
            text-align: center;
            color: #667eea;
            font-weight: 500;
            display: none;
            font-size: 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .spinner {
            border: 3px solid #e2e8f0;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 20px;
        }
        
        .rick-quote {
            font-style: italic;
            color: #0080ff;
            font-size: 0.9em;
            margin-top: 10px;
        }
        
        .video-controls {
            text-align: center;
            margin-top: 20px;
        }
        
        .video-button {
            background: linear-gradient(45deg, #00ff41, #0080ff);
            color: #000;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 10px;
        }
        
        .video-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,65,0.4);
        }
        
        .back-button {
            position: fixed;
            top: 24px;
            left: 24px;
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .back-button:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.5);
        }
    </style>
    <style>
        /* Modern professional overrides */
        :root {
            --bg: #f8fafc;
            --panel: #ffffff;
            --muted: #e2e8f0;
            --text: #1a202c;
            --subtle: #718096;
            --accent: #667eea;
            --accent-hover: #5a67d8;
            --success: #48bb78;
            --error: #f56565;
            --warning: #ed8936;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text);
            padding: 24px;
            line-height: 1.6;
        }

        .subtitles { display: none; }
        /* Minecraft shorts-style subtitle aesthetics */
        .subtitles {
            background: transparent;
            border: none;
            bottom: 12vh;
            color: #ffffff;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.15;
            font-size: clamp(20px, 4.2vw, 40px);
            text-align: center;
            text-shadow: 2px 2px 0px #000, -2px 2px 0px #000, 2px -2px 0px #000, -2px -2px 0px #000, 0 0 10px rgba(0,0,0,0.6);
            padding: 0 12px;
        }
        .subtitle-word { opacity: 0.95; transition: transform .18s ease; }
        .subtitle-word.past { color: #f3f4f6; }
        .subtitle-word.current { animation: pop .18s ease-out; transform: scale(1.08); }
        .subtitle-word.future { color: #d1d5db; opacity: 0.7; }
        .hl-red { color: #ef4444; }
        .hl-yellow { color: #f59e0b; }
        .hl-green { color: #10b981; }
        @keyframes pop {
            0% { transform: scale(0.96); }
            100% { transform: scale(1); }
        }

        .container {
            max-width: 900px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            box-shadow: 0 32px 64px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 48px 40px;
            color: #ffffff;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        .header::before { 
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M30 30c0 16.569-13.431 30-30 30s-30-13.431-30-30 13.431-30 30-30 30 13.431 30 30z'/%3E%3C/g%3E%3C/svg%3E");
        }
        .header h1 { 
            font-size: 3.2rem; 
            font-weight: 700;
            margin-bottom: 16px; 
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
            background: linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .header p { 
            font-size: 1.25rem; 
            color: rgba(255, 255, 255, 0.9); 
            font-weight: 400;
            position: relative;
            z-index: 1;
        }

        .main-content { 
            background: transparent; 
            color: var(--text); 
            padding: 48px 40px; 
        }

        .upload-section {
            border: 2px dashed #e2e8f0;
            background: rgba(102, 126, 234, 0.02);
            border-radius: 20px;
            padding: 48px 40px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .upload-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .upload-section:hover { 
            border-color: var(--accent); 
            background: rgba(102, 126, 234, 0.08); 
            transform: translateY(-2px);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.15);
        }
        .upload-section:hover::before {
            opacity: 1;
        }
        .upload-section.dragover { 
            border-color: var(--accent); 
            background: rgba(102, 126, 234, 0.12); 
            animation: pulse 1s infinite;
        }

        .upload-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            text-transform: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.01em;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }
        .upload-button::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        .upload-button:hover { 
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-2px); 
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
        }
        .upload-button:hover::before {
            left: 100%;
        }

        .file-info {
            margin: 24px 0;
            padding: 20px;
            background: rgba(102, 126, 234, 0.05);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 12px;
            color: #4a5568;
            font-size: 0.95rem;
        }
        .rick-quote { display: none; }

        .progress-bar { 
            height: 6px; 
            background: #e2e8f0; 
            border: none; 
            border-radius: 6px;
            margin: 24px 0;
        }
        .progress-fill { 
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); 
            animation: none; 
            background-size: auto;
            border-radius: 6px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .loading { 
            color: var(--accent); 
            font-size: 1rem;
            font-weight: 500;
        }
        #rickLoadingQuote { display: none; }

        .error {
            background: rgba(245, 101, 101, 0.1);
            color: #e53e3e;
            border: 1px solid rgba(245, 101, 101, 0.3);
            border-radius: 12px;
            padding: 20px;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .results-section { margin-top: 32px; }
        .summary-box {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 16px;
            padding: 32px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
        }
        .summary-box::before { display: none; }
        .summary-title { 
            color: #2d3748; 
            font-size: 1.5rem; 
            font-weight: 700; 
            text-shadow: none; 
            letter-spacing: -0.01em;
            margin-bottom: 20px;
        }
        .summary-text { 
            color: #4a5568; 
            text-shadow: none; 
            font-size: 1rem; 
            line-height: 1.7; 
            font-weight: 400;
        }

        .audio-section { margin-top: 24px; }
        .audio-player { 
            filter: none; 
            width: 100%;
            max-width: 400px;
            margin: 16px auto;
            border-radius: 8px;
        }

        .video-controls { display: none; }
        .video-button { background: #161a20; color: var(--text); border: 1px solid var(--muted); }
        .video-button:hover { box-shadow: none; border-color: var(--accent); }
        
        .back-button {
            background: rgba(255, 255, 255, 0.95);
            color: var(--accent);
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 600;
            position: fixed;
            top: 24px;
            left: 24px;
            z-index: 100;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .back-button:hover { 
            background: rgba(102, 126, 234, 0.1); 
            border-color: rgba(102, 126, 234, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.2);
        }

        .open-player {
            margin-top: 16px;
            background: var(--accent);
            color: #ffffff;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        .open-player:hover { background: var(--accent-hover); }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 16px;
            }
            
            .container {
                border-radius: 16px;
            }
            
            .header {
                padding: 32px 24px;
            }
            
            .header h1 {
                font-size: 2.4rem;
            }
            
            .header p {
                font-size: 1.1rem;
            }
            
            .main-content {
                padding: 32px 24px;
            }
            
            .upload-section {
                padding: 32px 24px;
            }
            
            .summary-box {
                padding: 24px;
            }
            
            .back-button {
                top: 16px;
                left: 16px;
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .upload-section {
                padding: 24px 16px;
            }
            
            .upload-button {
                padding: 14px 24px;
                font-size: 0.95rem;
            }
        }

        /* Upload section text styling */
        .upload-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
            letter-spacing: -0.01em;
        }
        
        .upload-section p {
            font-size: 1rem;
            color: #718096;
            font-weight: 400;
        }
    </style>
</head>
<body>
    <div class="video-container">
        <video id="minecraftVideo" loop muted>
            <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        <div class="video-overlay"></div>
        <button class="back-button" id="backButton">‚Üê Back to Upload</button>
    </div>
    
    <div class="subtitles" id="subtitles"></div>
    
    <div class="container">
        <div class="header">
            <h1>Document Summarizer</h1>
            <p>Upload a document to generate a concise summary.</p>
        </div>
        
        <div class="main-content">
            <div class="upload-section" id="uploadSection">
                <input type="file" id="fileInput" accept=".doc,.docx,.pdf,.txt" />
                <h3>Drop your document here</h3>
                <p>Supported formats: PDF, DOCX, TXT</p>
                <br>
                <button class="upload-button">Choose file</button>
            </div>
            
            <div class="file-info" id="fileInfo">
                <strong>Selected file:</strong> <span id="fileName"></span>
                <div class="rick-quote"></div>
            </div>
            
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p id="loadingText">Processing your document...</p>
                <div class="rick-quote" id="rickLoadingQuote"></div>
            </div>
            
            <div class="error" id="error"></div>
            
            <div class="results-section" id="results">
                <div class="summary-box">
                    <div class="summary-title">Summary</div>
                    <div class="summary-text" id="summaryText"></div>
                </div>
                
                <div class="audio-section">
                    <div class="summary-title">Audio summary</div>
                    <audio class="audio-player" id="audioPlayer" controls>
                        Your browser does not support the audio element.
                    </audio>
                    <button class="open-player" id="openPlayerBtn" style="display:none">Open video-style player</button>
                </div>
                
                <div class="video-controls">
                    <button class="video-button" id="playWithVideo">Play with background video</button>
                    <button class="video-button" id="stopVideo">Stop video</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Set PDF.js worker path
        pdfjsLib = window['pdfjs-dist/build/pdf'];
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const rickLoadingQuote = document.getElementById('rickLoadingQuote');
        const error = document.getElementById('error');
        const results = document.getElementById('results');
        const summaryText = document.getElementById('summaryText');
        const audioPlayer = document.getElementById('audioPlayer');
        const minecraftVideo = document.getElementById('minecraftVideo');
        const subtitles = document.getElementById('subtitles');
        const playWithVideoBtn = document.getElementById('playWithVideo');
        const stopVideoBtn = document.getElementById('stopVideo');
        const backButton = document.getElementById('backButton');

        // API configurations
         const SUMMARIZE_API_URL = '/api/summarize';
        const GENERATE_SPEECH_API_URL = '/api/generate-speech';
        const ASSEMBLYAI_API_URL = '/api/assemblyai';
        const GET_TOPIC_API_URL = '/api/get-topic';
        
        const ELEVENLABS_API_URL = 'https://api.elevenlabs.io/v1/text-to-speech';
        const ASSEMBLYAI_UPLOAD_URL = 'https://api.assemblyai.com/v2/upload';
        const ASSEMBLYAI_TRANSCRIPT_URL = 'https://api.assemblyai.com/v2/transcript';

        // Rick loading quotes
        const rickQuotes = [
            "*BURP* Science, Morty! Science!",
            "I'm processing this faster than your tiny brain could comprehend!",
            "This document is more boring than Jerry's job!",
            "Wubba lubba dub dub! Almost done...",
            "Your document is getting the full Rick treatment!",
            "I've seen interdimensional cable more interesting than this!"
        ];

        // Variables to store audio and subtitle data
        let audioBlob = null;
        let audioDuration = 0;
        let subtitleSegments = [];
        let currentSubtitleIndex = 0;
        let subtitleInterval = null;
        let wordTimestamps = [];
        let kidQuestion = "";
        let rickResponse = "";
        let kidUnderstanding = "";
        let currentTopic = "";

        // Drag and drop functionality
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadSection.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Video control buttons
        playWithVideoBtn.addEventListener('click', playVideoWithAudio);
        stopVideoBtn.addEventListener('click', stopVideoPlayback);
        backButton.addEventListener('click', goBackToUpload);

        // Topic to video mapping

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Page loaded');
            // Hide video container initially - it will only show after processing
            document.querySelector('.video-container').style.display = 'none';
            
            // Set default video but don't play it yet
            setVideoForTopic('default');
        });

        function handleFile(file) {
            // Validate file type
            const validTypes = [
                'application/pdf', 
                'application/msword', 
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 
                'text/plain'
            ];
            
            // Also check by file extension for browsers that might not report correct MIME types
            const validExtensions = ['.pdf', '.doc', '.docx', '.txt'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            
            if (!validTypes.includes(file.type) && !validExtensions.includes(fileExtension)) {
                showError('Unsupported file type. Please upload a PDF, DOC, DOCX, or TXT file.');
                return;
            }

            // Show file info
            fileName.textContent = file.name;
            fileInfo.style.display = 'block';
            
            // Process the file
            processDocument(file);
        }

        async function processDocument(file) {
            try {
                hideError();
                showLoading('Extracting text...');
                
                // Extract text from file
                const text = await extractTextFromFile(file);
                
                if (!text.trim()) {
                    throw new Error('The document appears to be empty.');
                }

                updateProgress(25);
                updateLoadingText('Analyzing document topic...');
                
                // Get topic category from Dobby analysis
                const documentTopic = await getTopicFromDobby(text);
                currentTopic = documentTopic;
                
                updateProgress(40);
                updateLoadingText('Generating summary...');
                
                // Get summary from Dobby LLM in Rick's style
                const summary = await getSummaryFromDobby(text);
                
                updateProgress(75);
                updateLoadingText('Creating audio summary...');
                
                // Set appropriate video based on topic
                setVideoForTopic(documentTopic);
                
                kidQuestion = generateKidQuestion(documentTopic, file.name);
                rickResponse = summary;
                kidUnderstanding = generateKidUnderstanding();
                
                // Convert dialogue to speech with gaps
                audioBlob = await convertDialogueToSpeechWithGaps(kidQuestion, rickResponse, kidUnderstanding);
                
                // Create subtitle segments based on estimated durations
                subtitleSegments = createSubtitleSegments(kidQuestion, rickResponse, kidUnderstanding);

                // Try fetching precise word timestamps with AssemblyAI
                try {
                    updateLoadingText('Aligning audio to words...');
                    wordTimestamps = await getAssemblyAIWordTimestamps(audioBlob);
                } catch (alignErr) {
                    console.warn('AssemblyAI alignment failed; using estimated segments.', alignErr);
                    wordTimestamps = [];
                }
                
                updateProgress(100);
                
                // Display results
                displayResults(summary, audioBlob);
                
            } catch (err) {
                console.error('Error processing document:', err);
                showError(err.message || 'Something went wrong while processing the document.');
            } finally {
                hideLoading();
            }
        }

        function extractTopicFromText(text) {
            // Improved topic extraction
            const words = text.toLowerCase().split(/\s+/);
            const stopWords = new Set(['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'this', 'that', 'these', 'those', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'will', 'would', 'could', 'should']);
            const wordCount = {};
            
            // Count word frequency, excluding stop words and short words
            words.forEach(word => {
                const cleanWord = word.replace(/[^a-zA-Z]/g, '');
                if (cleanWord.length > 4 && !stopWords.has(cleanWord)) {
                    wordCount[cleanWord] = (wordCount[cleanWord] || 0) + 1;
                }
            });
            
            // Find the most frequent meaningful word
            let maxCount = 0;
            let topic = "this document";
            for (const word in wordCount) {
                if (wordCount[word] > maxCount && wordCount[word] > 2) {
                    maxCount = wordCount[word];
                    topic = word;
                }
            }
            
            return topic.charAt(0).toUpperCase() + topic.slice(1);
        }

        async function getTopicFromDobby(text) {
            try {
                const response = await fetch(GET_TOPIC_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text
                    })
                });

                if (!response.ok) {
                    console.warn('Dobby topic analysis failed, falling back to simple extraction');
                    return extractTopicFromText(text);
                }

                const data = await response.json();
                const topicCategory = data.topic.toLowerCase();
                
                console.log('Dobby selected topic category:', topicCategory);
                return topicCategory;
                
            } catch (error) {
                console.warn('Dobby topic analysis error:', error);
                return extractTopicFromText(text);
            }
        }

        function getTopicVideo(topic) {
            const topicLower = topic.toLowerCase();
            
            // Video database with Vimeo embed URLs
            const videoDatabase = {
                // Computer - Technology and programming
                'computer': 'https://player.vimeo.com/video/1119359977?autoplay=1&loop=1&muted=1&background=1',
                'technology': 'https://player.vimeo.com/video/1119359977?autoplay=1&loop=1&muted=1&background=1',
                'programming': 'https://player.vimeo.com/video/1119359977?autoplay=1&loop=1&muted=1&background=1',
                'tech': 'https://player.vimeo.com/video/1119359977?autoplay=1&loop=1&muted=1&background=1',
                
                // Health - Medical and wellness
                'health': 'https://player.vimeo.com/video/1119360062?autoplay=1&loop=1&muted=1&background=1',
                'medical': 'https://player.vimeo.com/video/1119360062?autoplay=1&loop=1&muted=1&background=1',
                'medicine': 'https://player.vimeo.com/video/1119360062?autoplay=1&loop=1&muted=1&background=1',
                'healthcare': 'https://player.vimeo.com/video/1119360062?autoplay=1&loop=1&muted=1&background=1',
                
                // Business/Finance - Professional and financial
                'business/finance': 'https://player.vimeo.com/video/1119360025?autoplay=1&loop=1&muted=1&background=1',
                'business': 'https://player.vimeo.com/video/1119360025?autoplay=1&loop=1&muted=1&background=1',
                'finance': 'https://player.vimeo.com/video/1119360025?autoplay=1&loop=1&muted=1&background=1',
                'economy': 'https://player.vimeo.com/video/1119360025?autoplay=1&loop=1&muted=1&background=1',
                
                // AI - Artificial intelligence and automation
                'ai': 'https://player.vimeo.com/video/1119360199?autoplay=1&loop=1&muted=1&background=1',
                'artificial intelligence': 'https://player.vimeo.com/video/1119360199?autoplay=1&loop=1&muted=1&background=1',
                'machine learning': 'https://player.vimeo.com/video/1119360199?autoplay=1&loop=1&muted=1&background=1',
                'automation': 'https://player.vimeo.com/video/1119360199?autoplay=1&loop=1&muted=1&background=1',
                
                // Food - Culinary and nutrition
                'food': 'https://player.vimeo.com/video/1119360151?autoplay=1&loop=1&muted=1&background=1',
                'cooking': 'https://player.vimeo.com/video/1119360151?autoplay=1&loop=1&muted=1&background=1',
                'culinary': 'https://player.vimeo.com/video/1119360151?autoplay=1&loop=1&muted=1&background=1',
                'nutrition': 'https://player.vimeo.com/video/1119360151?autoplay=1&loop=1&muted=1&background=1',
                
                // Default fallback
                'default': 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4'
            };
            
            // Check for exact category matches first
            if (videoDatabase[topicLower]) {
                return videoDatabase[topicLower];
            }
            
            // Fallback: check for partial matches
            for (const category in videoDatabase) {
                if (topicLower.includes(category) || category.includes(topicLower)) {
                    return videoDatabase[category];
                }
            }
            
            // Return default video if no match found
            return videoDatabase.default;
        }

        function setVideoForTopic(topic) {
            const videoContainer = document.querySelector('.video-container');
            const videoUrl = getTopicVideo(topic);
            
            // Check if it's a Vimeo URL (needs iframe) or regular video URL
            if (videoUrl.includes('player.vimeo.com')) {
                // Use iframe for Vimeo videos
                videoContainer.innerHTML = `
                    <iframe id="minecraftVideo" 
                            src="${videoUrl}" 
                            width="100%" 
                            height="100%" 
                            frameborder="0" 
                            allow="autoplay; fullscreen; picture-in-picture" 
                            allowfullscreen
                            style="position: absolute; top: 50%; left: 50%; min-width: 100%; min-height: 100%; transform: translateX(-50%) translateY(-50%); object-fit: cover;">
                    </iframe>
                    <div class="video-overlay"></div>
                `;
                console.log(`Setting Vimeo iframe for topic "${topic}": ${videoUrl}`);
            } else {
                // Use regular video element for other URLs
                videoContainer.innerHTML = `
                    <video id="minecraftVideo" loop muted autoplay>
                        <source src="${videoUrl}" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class="video-overlay"></div>
                `;
                
                const video = document.getElementById('minecraftVideo');
                
                // Make sure video is ready to play
                video.onloadeddata = function() {
                    console.log(`Video for topic "${topic}" loaded successfully: ${videoUrl}`);
                };
                
                video.onerror = function(e) {
                    console.error(`Failed to load video for topic "${topic}": ${videoUrl}`, e);
                    // Fallback to default video
                    setVideoForTopic('default');
                };
                
                console.log(`Setting video for topic "${topic}": ${videoUrl}`);
            }
        }

        function generateKidQuestion(topic, filename) {
            // Remove file extension from filename for better context
            const cleanFilename = filename.replace(/\.[^/.]+$/, "");
            
            const questions = [
                `Hey Uncle Rick, I found this document called "${cleanFilename}" and it talks about ${topic}. Can you explain what it's all about?`,
                `Uncle Rick, I'm trying to understand this ${topic} stuff from the document. What does it really mean?`,
                `So Uncle Rick, this document mentions ${topic} a lot. Can you break it down for me in simple terms?`,
                `I'm confused about ${topic} from this document, Uncle Rick. Can you help me understand it better?`,
                `Uncle Rick, what's the main point about ${topic} in this document? It seems pretty complex.`
            ];
            
            return questions[Math.floor(Math.random() * questions.length)];
        }

        function generateKidUnderstanding() {
            const understandings = [
                `Oh wow, that actually makes a lot of sense now! Thanks Uncle Rick, you're the smartest!`,
                `Aha! So that's how it all works together. I get it now, thanks!`,
                `That's actually really cool when you explain it like that! Science is awesome!`,
                `Okay, I think I understand the main idea now. That's pretty interesting stuff!`,
                `Whoa, so that's the key to understanding it all! Thanks for making it simple, Uncle Rick!`
            ];
            
            return understandings[Math.floor(Math.random() * understandings.length)];
        }

        async function extractTextFromFile(file) {
            if (file.type === 'text/plain' || file.name.toLowerCase().endsWith('.txt')) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read this pathetic text file'));
                    reader.readAsText(file);
                });
            }
            
            if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                return extractTextFromPDF(file);
            }
            
            if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
                file.name.toLowerCase().endsWith('.docx')) {
                return extractTextFromDocx(file);
            }
            
            if (file.type === 'application/msword' || file.name.toLowerCase().endsWith('.doc')) {
                throw new Error('The .doc format is not supported. Please use .docx.');
            }
            
            throw new Error('Unsupported file type.');
        }

        async function extractTextFromPDF(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument({data: typedarray}).promise;
                        let fullText = '';
                        
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += pageText + '\n';
                        }
                        
                        if (!fullText.trim()) {
                            reject(new Error('No extractable text found in the PDF.'));
                            return;
                        }
                        
                        resolve(fullText.trim());
                    } catch (error) {
                        reject(new Error('Failed to extract text from PDF: ' + error.message));
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read the PDF file.'));
                reader.readAsArrayBuffer(file);
            });
        }

        async function extractTextFromDocx(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        const result = await mammoth.extractRawText({arrayBuffer: arrayBuffer});
                        resolve(result.value);
                    } catch (error) {
                        reject(new Error('Failed to extract text from DOCX: ' + error.message));
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read the DOCX file.'));
                reader.readAsArrayBuffer(file);
            });
        }

        async function getSummaryFromDobby(text) {
            const truncatedText = text.length > 12000 ? text.substring(0, 12000) + "..." : text;
            
            const response = await fetch(SUMMARIZE_API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: truncatedText
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Summarization failed: ${errorData.error || response.status}`);
            }

            const data = await response.json();
            return data.summary;
        }
        async function convertDialogueToSpeechWithGaps(kidQuestion, rickResponse, kidUnderstanding) {
    try {
        // Use specific voice IDs for consistency
        const rickVoiceId = "cgLpYGyXZhkyalKZ0xeZ"; // Antoni voice
        const kidVoiceId = "Hybl6rg76ZOcgqZqN5WN"; // Elli voice

        // Generate audio for each part
        const kidQuestionAudio = await generateSpeech(kidQuestion, kidVoiceId, 0.6, 0.8);
        const rickResponseAudio = await generateSpeech(rickResponse, rickVoiceId, 0.4, 0.9);
        const kidUnderstandingAudio = await generateSpeech(kidUnderstanding, kidVoiceId, 0.6, 0.8);

        // Combine audio with gaps
        return await combineAudioWithGaps([
            { audio: kidQuestionAudio, gap: 1.0 },
            { audio: rickResponseAudio, gap: 0.8 },
            { audio: kidUnderstandingAudio, gap: 0 }
        ]);
    } catch (error) {
        console.error('Dialogue conversion error:', error);
        throw new Error('Failed to generate audio: ' + error.message);
    }
}

        async function generateSpeech(text, voiceId, stability, similarityBoost) {
            const response = await fetch(GENERATE_SPEECH_API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text,
                    voiceId,
                    stability,
                    similarityBoost
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Text-to-speech API error: ${response.status} - ${errorText}`);
            }

            return await response.blob();
        }

        async function combineAudioWithGaps(audioSegments) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const buffers = [];
                
                // Convert all audio blobs to AudioBuffers
                for (const segment of audioSegments) {
                    const arrayBuffer = await segment.audio.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    buffers.push({ buffer: audioBuffer, gap: segment.gap });
                }
                
                // Calculate total duration
                let totalDuration = 0;
                buffers.forEach(item => {
                    totalDuration += item.buffer.duration + item.gap;
                });
                
                // Create a new buffer for the combined audio
                const combinedBuffer = audioContext.createBuffer(
                    buffers[0].buffer.numberOfChannels,
                    Math.ceil(totalDuration * audioContext.sampleRate),
                    audioContext.sampleRate
                );
                
                // Copy audio data with gaps
                let currentTime = 0;
                buffers.forEach(item => {
                    const startSample = Math.floor(currentTime * audioContext.sampleRate);
                    
                    for (let channel = 0; channel < item.buffer.numberOfChannels; channel++) {
                        const sourceData = item.buffer.getChannelData(channel);
                        const targetData = combinedBuffer.getChannelData(channel);
                        
                        for (let i = 0; i < sourceData.length; i++) {
                            if (startSample + i < targetData.length) {
                                targetData[startSample + i] = sourceData[i];
                            }
                        }
                    }
                    
                    currentTime += item.buffer.duration + item.gap;
                });
                
                // Convert back to blob
                const length = combinedBuffer.length * combinedBuffer.numberOfChannels * 2;
                const arrayBuffer = new ArrayBuffer(length);
                const view = new DataView(arrayBuffer);
                const channels = [];
                
                for (let i = 0; i < combinedBuffer.numberOfChannels; i++) {
                    channels.push(combinedBuffer.getChannelData(i));
                }
                
                let offset = 0;
                for (let i = 0; i < combinedBuffer.length; i++) {
                    for (let channel = 0; channel < combinedBuffer.numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, channels[channel][i]));
                        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                // Create WAV blob
                const wavBlob = createWavBlob(arrayBuffer, combinedBuffer.sampleRate, combinedBuffer.numberOfChannels);
                return wavBlob;
                
            } catch (error) {
                console.error('Audio combining error:', error);
                // Fallback: just return the first audio segment
                return audioSegments[0].audio;
            }
        }
        function createWavBlob(audioData, sampleRate, numberOfChannels) {
            const header = new ArrayBuffer(44);
            const view = new DataView(header);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + audioData.byteLength, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, audioData.byteLength, true);
            
            return new Blob([header, audioData], { type: 'audio/wav' });
        }

        // AssemblyAI integration for word timestamps
        async function uploadToAssemblyAI(audioBlob) {
            const response = await fetch(ASSEMBLYAI_UPLOAD_URL, {
                method: 'POST',
                headers: {
                    'authorization': ASSEMBLYAI_API_KEY,
                    'transfer-encoding': 'chunked'
                },
                body: audioBlob
            });
            if (!response.ok) {
                const err = await response.text();
                throw new Error(`AssemblyAI upload failed: ${response.status} ${err}`);
            }
            const data = await response.json();
            return data.upload_url;
        }

        async function requestAssemblyAITranscription(audioUrl) {
            const response = await fetch(ASSEMBLYAI_TRANSCRIPT_URL, {
                method: 'POST',
                headers: {
                    'authorization': ASSEMBLYAI_API_KEY,
                    'content-type': 'application/json'
                },
                body: JSON.stringify({
                    audio_url: audioUrl,
                    punctuate: true,
                    format_text: true
                })
            });
            if (!response.ok) {
                const err = await response.text();
                throw new Error(`AssemblyAI transcript create failed: ${response.status} ${err}`);
            }
            const data = await response.json();
            return data.id;
        }

        async function pollAssemblyAITranscript(transcriptId) {
            const url = `${ASSEMBLYAI_TRANSCRIPT_URL}/${transcriptId}`;
            while (true) {
                const resp = await fetch(url, { headers: { 'authorization': ASSEMBLYAI_API_KEY } });
                if (!resp.ok) {
                    const err = await resp.text();
                    throw new Error(`AssemblyAI polling failed: ${resp.status} ${err}`);
                }
                const data = await resp.json();
                if (data.status === 'completed') return data;
                if (data.status === 'error') throw new Error(`AssemblyAI transcription error: ${data.error}`);
                await new Promise(r => setTimeout(r, 1500));
            }
        }

      async function getAssemblyAIWordTimestamps(audioBlob) {
    try {
        console.log('Starting AssemblyAI transcription...');
        
        const formData = new FormData();
        formData.append('audio', audioBlob, 'audio.wav');
        
        const response = await fetch(ASSEMBLYAI_API_URL, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('AssemblyAI API error:', errorText);
            throw new Error(`AssemblyAI proxy error: ${response.status}`);
        }

        const data = await response.json();
        console.log('AssemblyAI response:', data);

        // Your API returns the words array directly, not wrapped in an object
        const words = Array.isArray(data) ? data : [];
        
        if (words.length === 0) {
            console.warn('No words returned from AssemblyAI');
            return [];
        }

        // Validate and format the word timestamps
        const formattedWords = words.map(word => ({
            text: word.text,
            start: word.start, // AssemblyAI returns milliseconds
            end: word.end,
            confidence: word.confidence || 0.8
        }));

        console.log(`Successfully processed ${formattedWords.length} words from AssemblyAI`);
        return formattedWords;
        
    } catch (error) {
        console.error('AssemblyAI alignment failed:', error);
        // Don't silently fail - let the user know what happened
        showError(`Subtitle alignment failed: ${error.message}. Using estimated timing instead.`);
        return [];
    }
}


        
function createSubtitleSegments(kidQuestion, rickResponse, kidUnderstanding) {
    const segments = [];
    let currentTime = 0;
    
    // Kid question segment
    const kidDuration = estimateDuration(kidQuestion);
    segments.push({
        text: kidQuestion,
        start: currentTime,
        end: currentTime + kidDuration
    });
    currentTime += kidDuration + 1.0; // Add gap after kid question
    
    // Rick response segment
    const rickDuration = estimateDuration(rickResponse);
    segments.push({
        text: rickResponse,
        start: currentTime,
        end: currentTime + rickDuration
    });
    currentTime += rickDuration + 0.8; // Add gap after Rick's response
    
    // Kid understanding segment
    const understandingDuration = estimateDuration(kidUnderstanding);
    segments.push({
        text: kidUnderstanding,
        start: currentTime,
        end: currentTime + understandingDuration
    });
    
    return segments;
}

        function estimateDuration(text) {
            // Estimate speech duration based on word count (average 0.5 seconds per word)
            const wordCount = text.split(' ').length;
            return Math.max(2, wordCount * 0.5); // Minimum 2 seconds
        }

        // Show the full-screen video player and subtitles, hide the main UI
        function showVideoPlayer() {
            document.querySelector('.video-container').style.display = 'block';
            document.querySelector('.subtitles').style.display = 'block';
            document.querySelector('.container').style.display = 'none';
            backButton.style.display = 'block';
        }
        
        // Go back to upload interface
        function goBackToUpload() {
            document.querySelector('.video-container').style.display = 'none';
            document.querySelector('.subtitles').style.display = 'none';
            document.querySelector('.container').style.display = 'block';
            backButton.style.display = 'none';
            
            // Stop any playing audio/video
            stopVideoPlayback();
        }

        function displayResults(summary, blob) {
            summaryText.textContent = summary;
            
            // Create audio URL
            const audioUrl = URL.createObjectURL(blob);
            audioPlayer.src = audioUrl;
            
            // Get audio duration for video playback
            const audio = new Audio();
            audio.src = audioUrl;
            audio.addEventListener('loadedmetadata', () => {
                audioDuration = audio.duration;

                // Automatically show the video player after processing
                setTimeout(() => {
                    showVideoPlayer();
                    playVideoWithAudio();
                }, 1000);
            });
            
            results.style.display = 'block';
            results.scrollIntoView({ behavior: 'smooth' });
        }

        function playVideoWithAudio() {
            if (!audioBlob) {
                showError("No audio available to play.");
                return;
            }
            
            const minecraftVideo = document.getElementById('minecraftVideo');
            
            // Handle iframe (Google Drive) vs video element
            if (minecraftVideo.tagName === 'IFRAME') {
                // For iframe, we can't control playback directly, just let it play
                console.log('Playing Google Drive video via iframe');
            } else {
            // Reset video
            minecraftVideo.currentTime = 0;
            // Play the video
            minecraftVideo.play();
            }
            
            // Play the audio using the existing audio element for accurate timing
            const audioUrl = URL.createObjectURL(audioBlob);
            audioPlayer.src = audioUrl;
            audioPlayer.play();
            
            // Start subtitle display using the audio player's currentTime
            startSubtitles(audioPlayer);
            
            // Return to upload page when audio finishes
            audioPlayer.onended = function() {
                if (minecraftVideo.tagName === 'VIDEO') {
                minecraftVideo.pause();
                }
                clearInterval(subtitleInterval);
                subtitles.style.display = 'none';
                
                // Automatically go back to upload page after audio ends
                setTimeout(() => {
                    goBackToUpload();
                }, 2000); // Wait 2 seconds before returning
            };
        }

        function stopVideoPlayback() {
            const minecraftVideo = document.getElementById('minecraftVideo');
            
            // Handle iframe vs video element
            if (minecraftVideo && minecraftVideo.tagName === 'VIDEO') {
                minecraftVideo.pause();
                minecraftVideo.currentTime = 0;
            }
            // For iframe, we can't control playback directly
            
            // Stop any playing audio
            const allAudio = document.querySelectorAll('audio');
            allAudio.forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });
            
            // Clear subtitle interval and hide subtitles
            clearInterval(subtitleInterval);
            subtitles.style.display = 'none';
            currentSubtitleIndex = 0;
        }

       
function startSubtitles(audio) {
    clearInterval(subtitleInterval);
    
    console.log('Starting subtitles with', wordTimestamps.length, 'words');
    
    // Use AssemblyAI word timestamps if available
    if (wordTimestamps.length > 0) {
        console.log('Using precise word-level timing from AssemblyAI');
        
        subtitleInterval = setInterval(() => {
            const currentTime = audio.currentTime * 1000; // convert to milliseconds
            
            // Find words that should be displayed in a smaller window around current time
            const windowBefore = 800; // 0.8 seconds before (reduced from 1.5s)
            const windowAfter = 1200;  // 1.2 seconds after (reduced from 2.5s)
            
            const visibleWords = wordTimestamps.filter(word => {
                return word.start >= (currentTime - windowBefore) && 
                       word.start <= (currentTime + windowAfter);
            });
            
            if (visibleWords.length > 0) {
                // Limit to maximum 4-5 words for easier reading
                const maxWords = 4;
                const limitedWords = visibleWords.slice(0, maxWords);
                
                // Create HTML for words with timing states
                const wordsHtml = limitedWords.map(word => {
                    let state = 'future';
                    if (currentTime >= word.start && currentTime <= word.end) {
                        state = 'current';
                    } else if (currentTime > word.end) {
                        state = 'past';
                    }
                    
                    return `<span class="subtitle-word ${state}">${word.text}</span>`;
                }).join(' ');
                
                subtitles.innerHTML = wordsHtml;
                subtitles.style.display = 'block';
            } else {
                // No words in current window
                subtitles.style.display = 'none';
            }
        }, 150); // Update every 150ms for slower, smoother transitions
        
    } else {
        console.log('Falling back to segment-based subtitles');
        // Fall back to segment-based subtitles
        subtitleInterval = setInterval(() => {
            const currentTime = audio.currentTime;
            
            const currentSegment = subtitleSegments.find(segment => 
                currentTime >= segment.start && currentTime <= segment.end
            );
            
            if (currentSegment) {
                // Split segment into smaller chunks for better display
                const words = currentSegment.text.split(' ');
                const maxWordsPerLine = 4; // Reduced from 8 to 4 for easier reading
                
                if (words.length <= maxWordsPerLine) {
                    subtitles.textContent = currentSegment.text;
                } else {
                    // Show words progressively with slower progression
                    const segmentDuration = currentSegment.end - currentSegment.start;
                    const timeInSegment = currentTime - currentSegment.start;
                    const progressRatio = timeInSegment / segmentDuration;
                    // Slower word progression - multiply by 0.7 to slow down
                    const wordsToShow = Math.min(words.length, Math.floor(progressRatio * words.length * 0.7) + maxWordsPerLine);
                    
                    subtitles.textContent = words.slice(Math.max(0, wordsToShow - maxWordsPerLine), wordsToShow).join(' ');
                }
                
                subtitles.style.display = 'block';
            } else {
                subtitles.style.display = 'none';
            }
        }, 150); // Slower update interval for smoother reading
    }
}

        function showLoading(text) {
            loadingText.textContent = text;
            loading.style.display = 'block';
            progressBar.style.display = 'block';
            
            // Update Rick quote randomly
            rickLoadingQuote.textContent = rickQuotes[Math.floor(Math.random() * rickQuotes.length)];
        }

        function hideLoading() {
            loading.style.display = 'none';
            progressBar.style.display = 'none';
            updateProgress(0);
        }

        function updateLoadingText(text) {
            loadingText.textContent = text;
            // Update Rick quote
            rickLoadingQuote.textContent = rickQuotes[Math.floor(Math.random() * rickQuotes.length)];
        }

        function updateProgress(percentage) {
            progressFill.style.width = percentage + '%';
        }

        function showError(message) {
            error.textContent = message;
            error.style.display = 'block';
        }

        function hideError() {
            error.style.display = 'none';
        }
    </script>
</body>
</html>
